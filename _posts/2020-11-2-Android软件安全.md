---
title: Android软件安全与逆向分析
author: 阿航
date: 2020-11-2 19:23:00 +0800
categories: [网络安全,Android软件安全]
tags: android安全


---

## 1.Dalvik虚拟机

>1. **特点**
>
>  * 体积小， 占用内存空间少。
>  * 专有的DEX ( Dalvik Exe c utable ）可执行文件格式， 体积小， 执行速度快。
>  * 常量池采用32位索引值， 对类方法名、 字段名、 常量的寻址速度快。
>  * 基于寄存器架构， 同时拥有 一套完整的指令系统。
>  * 提供了对象生命周期管理、 堆枝管理、 线程管理、 安全和异常管理及垃圾回收等重要功能。
>  * 所有的Android程序都运行在Android系统进程中， 每个进程都与一个 Dalvik虚拟机实例对应。
>
>2. **Dalvik虚拟机与Java虚拟机的区别**
>
>  * 运行的字节码不同
>
>  * Dalvik可执行文件的体积更小。(dx工具：将Java字节码转换为Dalvik字节码)
>
>    dx对所有Java类文件中的常量池进行了分解， 消除了其中的冗余信息，然后将它们重新组合形成一个常量池，并让所有类文件共享这个常量池。
>
>    <img src="C:\Users\lxh\Documents\GitHub\lvxinghang.github.io\assets\img\sample\dx.png" style="zoom: 80%;" />
>
>  * 虚拟机架构不同
>
>    java: 基于`栈架构`。
>
>    Dalvik: 基于`寄存器架构`。
>
>    ![](C:\Users\lxh\Documents\GitHub\lvxinghang.github.io\assets\img\sample\JVM.png)
>
>    iload_1：i表示int类型，load表示将局部变量存入Java栈，1表示要操作的哪个局部变量。
>
>    
>
>    ![](C:\Users\lxh\Documents\GitHub\lvxinghang.github.io\assets\img\sample\Dalvik虚拟机运行状态.png)
>
>    add-int v0,v3,v4：将v3与v4相加，并将值存入v0。
>
>3. 虚拟机的执行方式
>
>  * 即时编译（Just-in-time Comp ilation ，丑T）又称动态编译， 是一种通过在运行时将字节码翻译为机器码使得程序的执行速度加快的技术。
>  * 主流的JIT包括两种字节码编译方式
>    * method方式：以函数或方法为单位进行编译。
>    * trace方式：以trace为单位进行编译。

## 2.Dalvik 语言基础

>  1. **Dalvik字节码**
>
>  >* **类型**
>  >
>  >  * 基本类型
>  >
>  >  * 引用类型
>  >
>  >  * Dalvik字节码类型描述符
>  >
>  >    |   语法   |    Z    |  B   |  J   |     L      |  [   |
>  >    | :------: | :-----: | :--: | :--: | :--------: | :--: |
>  >    | **含义** | boolean | byte | long | Java类类型 | 数组 |
>  >
>  >  * Lpackage/name/ObjectName；
>  >
>  >    L 表示后面眼着一 个Java类，package/name/表示对象所在 的包，ObjectName表示对象的名称，分号表示对象名结束。
>  >
>  >* **方法**
>  >
>  >  * ```java
>  >    Lpackage/name/ObjectName;->MethodName(III)Z
>  >    ```
>  >
>  >    MethodName为具体的方法名，(III)Z是方法的签名部分， 括号内的III 为方法的参数（在此为三个整型参数)，z表示方法的返回类型。
>
>  ****
>
>  2. **Dalvik指令集**
>
>  * 指令类型
>
>    * ```java
>      move-wide/from16 vAA, vBBBB
>      ```
>
>      * move为基础字节码；
>
>      * -wide为名称后缀，表示指令操作 的数据宽度(64位)；
>
>      * from16为字节码后缀，表示源为一个16位的寄存器引用变量；
>
>      * vAA为目的寄存器，取值范围为v0～v255；
>
>      * vBBBB为源寄存器， 取值范围为v0～v65535；
>
>    * 空操作指令
>
>      * 助记符为nop,值为00；
>
>    * 数据操作指令
>
>      * ```java
>        move-wide vA, vB
>        ```
>
>        指令用于为4位的寄存器对赋值， 源寄存器与目的寄存器都为4位。
>
>      * ```java
>        move-result vAA
>        ```
>
>        指令用于将上 一 个invoke类型指令操作的单字非对象结果赋予vAA寄存器。
>
>    * 返回指令
>
>      * ```java
>        return vAA
>        ```
>
>        指令表示函数返回 一 个32位非对象类型的值， 返回值为8位寄存器vAA。
>
>    * 数据定义指令
>
>      * ```java
>        const/16 vAA, #+BBBB
>        ```
>
>        指令用于将数值符号扩展为32位后赋予寄存器vAA。
>
>    * 锁指令
>
>      * | monitor-enter vAA | monitor-exit vAA |
>        | :---------------: | :--------------: |
>        | 为指定对象获取锁  | 释放指定对象的锁 |
>
>    * 实例操作指令
>
>      * ```java
>        check-cast vAA, type@BBBB
>        ```
>
>        指令用于将vAA寄存器中的对象引用转换成指定的类型。
>
>      * ```java
>        new-instance vAA, type@BBBB
>        ```
>
>        指令用于构造一个指定类型对象的新实例， 并将对象引用赋值给vAA寄存器 。 类型符type指定的类型不能是数组类。
>
>      * ```java
>        instance-of vA, vB, type@CCCC
>        ```
>
>        指令用于判断vB寄存器中的对象引用是否可以转换成指定的类型，如果可以就为vA寄存器赋值1，否则为vA寄存器赋值为0。
>
>    * 数组操作指令
>
>      * ```java
>        array-length vA, vB
>        ```
>
>        指令用于获取给定vB寄存器中数组的长度， 并将值赋予vA寄存器。
>
>      * ```java
>        arrayop vAA, vBB, vCC
>        ```
>
>        * 指令用于对vBB寄存器指定的数组元素进行取值与赋值；
>        * vCC寄存器用于指定数组元素的索引；
>        * vAA寄存器用于存放读取的或需要设置的数组元素的值；
>        * 读取元素时使用aget类指令， 为元素赋值时使用aput类指令；
>        
>      * ```java
>        new-array vA, vB, type@CCCC
>        ```
>
>        指令用于构造指定类型（type@CCCC ）和大小（vB）的数组，并将值赋予vA寄存器。
>
>    * 跳转指令
>
>      * 无条件跳转指令goto
>
>        ```java
>        goto/16 +AAAA
>        ```
>
>        指令用于无条件跳转到指定偏移处， 偏移量 AAAA不能为0。
>
>      * ```java
>        packed-switch vAA, +BBBBBBBB
>        ```
>
>        * 分支跳转指令，vAA寄存器为switch分支中需要判断的值，BBBBBBBB指向一个packed-switch -payload格式的偏移表， 表中的值是递增的偏移量。
>        * 若packed改为sparse，则表中的值是无规律的偏移量。
>
>      * ```java
>        if-test vA, v8, +CCC
>        ```
>
>        * if-test类型指令如下
>
>          |  smali   |   if-eq    |   if-ne    |   if-lt   |   if-ge    |   if-gt   |   if-le    |
>          | :------: | :--------: | :--------: | :-------: | :--------: | :-------: | :--------: |
>          | **java** | if(vA==vB) | if(vA!=vB) | if(vA<vB) | if(vA>=vB) | if(vA>vB) | if(vA<=vB) |
>
>      * ```java
>        if-testz vAA, +BBBB
>        ```
>
>        * 指令将vAA寄存器的值与0进行比较，若比较结果满足或值为0，就跳转。
>
>    * 比较指令
>
>      * | cmpl-float                                         | cmpg-float          | cmpl -double             | cmpg-double             |
>        | :------------------------------------------------- | ------------------- | ------------------------ | ----------------------- |
>        | 若vBB>vCC，结果为-1; 若=，则结果为0;若<，则结果为1 | 若vBB>vCC，结果为1. | 若vBB对>vCC对，结果为-1. | 若vBB对>vCC对，结果为1. |
>
>    * 字段操作指令
>
>      * 普通字段的指令前缀为i。
>      * 静态字段的指令前缀为s。
>
>    * 数据运算指令
>
>      | binop vAA, vBB, vCC | 将vBB 寄存器与vCC 寄存器进行运算， 将运算结果保存到vAA寄存器中 |
>      | ------------------- | ------------------------------------------------------------ |
>      | **binop/2addr  vA, vB** | **将vA寄存器与 vB寄存器进行运算， 将运算结果保存到vA寄存器中** |
>      | **rem-type**        | **vBB % vCC**                                                |
>      | **shl-type**        | **vBB << vCC**                                             |
>
>    
>
>

## 3.Android文件格式

>1. **库文件**
>   1. jar包
>      * zip格式的压缩包文件，放着编译后Java代码的class文件的集合。
>   2. aar包
>      * 既包含了代码，又包含了开发中所有使用的资源数据，解决了手动复制图片，声音，布局等资源的繁琐。
>2. **APK**
>   1. 
>
>













