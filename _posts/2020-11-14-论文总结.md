---
title: 论文总结
author: 阿航
date: 2020-11-14 14:50:00 +0800
categories: [总结]
tags: 总结
---



### 1. A Review of Android Malware Detection Approaches Based on Machine Learning

​		(基于机器学习的安卓恶意软件检测方法综述)

**恶意软件的分类**

1. 攻击目标和行为
2. 分布和感染路径
3. 权限获取模式

**IV.基于机器学习的ANDROID恶意软件检测方法**

>1. **基于学习方法的分类**
>
>  * 监督学习
>  * 无监督学习
>  * 半监督学习
>  * 强化学习
>
>2. **机器学习大致可以分为具有不同理论思想的五个范式**
>
>  * 象征主义者
>  * 连接主义者
>  * 进化主义者
>  * 贝叶斯主义者
>  * 类比者
>
>3. **机器学习方法解决问题步骤**
>
>  * 抽象出要解决的问题
>  * 样本数据获取与分析
>  * 数据预处理
>  * 特征筛选
>  * 模型挑选与训练
>  * 模型评估与优化
>  * 用新数据集实现预测并解决实际问题
>  * 评估机器学习方法在新数据集上的学习性能
>
>4. **数据集**
>
>  1. **样例获取**
>
>* 良性软件
> 
>  * 通过`appstore`下载，或用工具`VirusTotal`,`AndroBugs`。
>* 恶意软件
>  * `RmvDroid`：`which claimed to be the first large-scale and reliable Android malware dataset`。
>  * `MamaDroid`
>  * `AndroZoo`
>  * `Drebin`
>  * `MalGenome`
>
>  2. 数据预处理和特征筛选
>
>* 数据预处理
>
>  * Data cleaning
>
>  * Data integration
>
>  * Data reduction
>
>  * Data transformation
>
>* 特征筛选
>
>  * Generation
>
>  * Evaluation
>
>  * Stopping criterion
>
>  * Validation
>
>   3. Android权限是判断应用程序恶意性的最佳单一指标
>  4. **Android恶意软件检测中常用的模型和算法**
>
> 决策树(Decision Trees)
> 
>6. **未来有待研究的课题**
>
> * 样本集的建立
>  * 数据的优化与处理
>  * 特征提取与建立
>  * 机器学习的应用
>  * 分类器的评价

### 2. A Two-Layer Deep Learning Method for Android Malware Detection Using Network Traffic

>  (基于网络流量的Android恶意软件检测的两层深度学习方法)
>
>  1. 检测恶意软件的两层方法
>     * 第一层：基于权限，意图，组件信息的静态检测模型。
>     * 第二层：CACNN将CNN和自编码器级联，通过网络流量特征检测恶意软件。
>     
>  2. 思路
>     
>     * 首先将静态特征与全连通神经网络相结合，对恶意软件进行检测并通过实验验证其有效性，然后结果（来自第一层的良性应用）被输入到第二层。在第二层，采用一种新的方法CACNN将CNN和自动编码器级联，通过应用程序的网络流量特征来检测恶意软件。
>     
>  3. 本文检测恶意软件方法
>     * 基于权限，意图和组件信息的静态恶意软件检测。将静态特征数据集输入到一个完全连通的神经网络中，检测恶意软件并通过实验验证其有效性。
>     *  基于网络流量的有效移动恶意软件检测。
>     * 两层检测模型。第一层，应用全连通神经网络对静态特征进行分析，并将结果输入第二层。第二层中对网络流量特征检测结果进行分析，证明CACNN模型能够有效识别恶意软件。
>     
>  4. 数据集
>
>     * CICAndMal2017
>
>  5. 网络流量分析
>
>     * 所有的网络流量都是从一个完全连接的神经网络模型的最后一个输出良性应用程序中获得的。然后，将采集到的网络流量数据输入到CACNN层。
>       CACNN层包含两部分：
>
>       * 一种是二进制分类模型，用来判断应用程序是否恶意。
>
>       * 另一种是多分类模型，它可以根据类别和恶意家族对恶意软件进行分类。
>
>     * 网络流量数据预处理
>
>       * 第一，流量片段
>       * 第二，流量调整，生成训练/测试数据集
>       * 第三，图像生成，TFRecord变换
>
>  6. 总结
>
>     * 在本研究中，提出了一个两层的Android恶意软件检测模型。第一层是基于权限、意图和组件信息的静态恶意软件检测模型。将静态特征与全连通神经网络相结合进行恶意软件检测，并通过实验验证了该方法的有效性。然后，结果（良性应用）被输入下一层。在第二层，采用一种新的级联深度学习CACNN方法来检测应用程序的网络流量特征。实验结果表明，我们的方法能够有效地识别恶意Android应用程序。此外，新的两层模型还可以根据恶意软件的类别和恶意家族进行检测。总的来说，结合两个层次的检测工作可以进一步提高检测效率。
>

### 3.基于抽象语法树的智能化漏洞检测系统(Astor)

1. 主要思想

   ​	利用静态分析工具将源代码解析成`抽象语法树(AST)`形式, 然后在`AST`的基础上提取结构化信息, 并将其转化为源代码的完整表征。最后使用神经网络模型学习这种结构化表征, 构建漏洞检测器。

2. 神经网络应用于漏洞检测步骤

   * 数据集预处理
   * 使用词向量模型将数据转换为向量
   * 利用神经网络模型学习向量表征, 构造漏洞检测器

3. 结构化数据集的生成

   1. 将源代码解析为有标签的代码切片

      生成`代码切片(CG)`: 

      1. 构建候选漏洞元素：`库/API 函数调用`、`数组使用`、`指针使用`或`表达式定义`。
      2. 构建候选漏洞代码段：根据候选漏洞元素进行代码切片。

   2. 将代码切片补全语法信息后进一步转化为抽象语法树

      `CG`-->`FG(语法结构完整的代码切片)`--> AST

   3. 将抽象语法树表征为代码链并映射成向量格式

4. Astor总体架构

   * 学习阶段

     1. 表征抽象语法树

        ​	抽象语法树 --> 代码链 --> 符号表示 --> 向量

     2. 训练神经网络

        ​	带有漏洞的代码链具有“1”的标签, 反之具有“0”的标签。

   * 检测阶段

     1. 表征抽象语法树
     2. 漏洞检测

5. 展望

   * (**漏洞分类**)基于本文所提出的方法训练出适用于多分类的漏洞检测系统, 且能够识别出样本存在哪一类漏洞。
   * (**定位漏洞**)针对切片级的样本开展漏洞定位研究, 识别具体漏洞代码位置。

### 4. 基于代码属性图及注意力双向LSTM的漏洞挖掘方法

 1. 主要思想

    ​	源代码 --> 代码属性图 --> (编码算法) --> 特征向量 --> 训练神经网络(双向LSTM和注意力机制) --> 漏洞检测

 2. 注意力机制

    ​	来源于人脑在接收外部信息时会将注意力集中在部分关键信息上，过滤不重要的信息。可以概括成对**注意力权重向量**的学习，权重向量反应了当前元素和其它元素的关联程度(元素当前的重要程度)。

    * 柔性注意力
    * 刚性注意力

 3. 代码属性图

    ​	一种综合了抽象语法树(AST)，控制流图(CFG)，和程序依赖图(PDG)的联合数据结构，包含了代码的控制依赖，数据依赖以及语法结构等语义信息，是目前语义信息最为全面的抽象图结构之一。

 4. 步骤

    * 利用开源工具Joern对C/C++源码进行分析，生成代码属性图。
    * 程序切片(裁剪掉与敏感操作无关的语句)：通过**正则匹配词法分析技术**查找函数的敏感操作语句，基于**程序依赖图进行图可达性分析的程序切片**。
    * 特征张量编码

 5. 结论

    * 本方法将漏洞挖掘视为一个二分类问题，只能预测函数中是否有漏洞，对函数中存在多个漏洞的检测能力有待提高。
    * 本方法以单个函数为单位进行漏洞检测，没有考虑调用的上下文。

### 5. SySeVR: A Framework for Using Deep Learning to Detect Software Vulnerabilities

1. 主要思想

   程序切片 --> 代码段 --> 数据预处理 --> 训练BGRU模型

   基于语法，语义和向量表征

2. 贡献

   ​	引入并定义了基于语法的漏洞候选 Syntax-based Vulnerability Candidates (**SyVCs**)和基于语义的漏洞候选 Semantics-based Vulnerability Candidates (**SeVCs**)的概念，并设计了计算算法，SyVCs反映了漏洞语法特征，SeVCs对SyVCs进行扩展，以容纳数据依赖和控制依赖诱导的语义信息。相应地，该框架被称为基于语法、基于语义和向量表示，简称SySeVR。

3. 程序切片技术

   CFG(数据依赖，控制依赖) --> 定义PDG --> 提取切片并打标 --> Word2Vec --> 向量 --> bgru模型 --> 测试结果

4. 局限性

   1）只适用于C/C++源码的漏洞检测。

   2）改进生成SyVCs和SeVCs的算法，容纳更多用于检测漏洞的语法/语义信息。

### 6. VulDeeLocator: A Deep Learning-based Fine-grained Vulnerability Detector

使用**word embedding**编码向量；

1. 该篇论文与SySeVR同作者，VulDeeLocator相对于SySeVR有了更高的漏洞检测能力，与高定位精度（加入了漏洞定位）。

2. 创新点

   1）加入中间代码来表示语义信息（利用中间代码来容纳基于源代码的表示无法传递的语义信息）

   2）实现漏洞精确定位 (定位到漏洞所在的行）

3. VulDeeLocator的输入

   输入的C源码需要满足的要求：

   * c程序可以编译成中间代码，如LLVM中间代码
   * 漏洞程序附带漏洞位置的描述

4. VulDeeLocator分为两个部分

   1）将源代码表示为中间代码

   * 源码提取sSyVCs(具有某些漏洞语法特征的代码片段)
   * 根据sSyVCs从中间代码生成iSeVCs

   2）利用中间代码检测和定位漏洞

   * 将从训练程序中提取到的iSeVCs标记为"有漏洞"或"无漏洞"和标记漏洞位置
   * 用ISEVC及其标签的向量训练神经网络模型
   * 用训练好的神经网络模型检测和定位目标程序中的漏洞

5. 标记iSeVCs

   ​	如果一个iSeVC中包含已知漏洞，该iSeVC就会被标记为
   iSeVC中的漏洞的行号（即漏洞的位置）

   ​	否则，iSeVC被标记为 "0"

6. 局限性

   1）仅支持C源程序中的漏洞

   2）VulDeeLocator 需要将程序源代码编译成中间代码，并且不能在程序源代码无法编译时使用



​	

​        











